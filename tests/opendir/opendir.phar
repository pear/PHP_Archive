<?php
error_reporting(1803);
if (function_exists('mb_internal_encoding')) {
    mb_internal_encoding('ASCII');
}
if (!class_exists('PHP_Archive')) {/**
 * PHP_Archive Class (implements .phar)
 *
 * @package PHP_Archive
 * @category PHP
 */
/**
 * PHP_Archive Class (implements .phar)
 *
 * PHAR files a singular archive from which an entire application can run.
 * To use it, simply package it using {@see PHP_Archive_Creator} and use phar://
 * URIs to your includes. i.e. require_once 'phar://config.php' will include config.php
 * from the root of the PHAR file.
 *
 * Gz code borrowed from the excellent File_Archive package by Vincent Lascaux.
 *
 * @copyright Copyright David Shafik and Synaptic Media 2004. All rights reserved.
 * @author Davey Shafik <davey@synapticmedia.net>
 * @author Greg Beaver <cellog@php.net>
 * @link http://www.synapticmedia.net Synaptic Media
 * @version Id$
 * @package PHP_Archive
 * @category PHP
 */

class PHP_Archive
{
    const GZ = 0x00001000;
    const BZ2 = 0x00002000;
    const SIG = 0x00010000;
    const SHA1 = 0x0002;
    const MD5 = 0x0001;
    const SHA256 = 0x0003;
    const SHA512 = 0x0004;
    const OPENSSL = 0x0010;
    /**
     * Whether this archive is compressed with zlib
     *
     * @var bool
     */
    private $_compressed;
    /**
     * @var string Real path to the .phar archive
     */
    private $_archiveName = null;
    /**
     * Current file name in the phar
     * @var string
     */
    protected $currentFilename = null;
    /**
     * Length of current file in the phar
     * @var string
     */
    protected $internalFileLength = null;
    /**
     * true if the current file is an empty directory
     * @var string
     */
    protected $isDir = false;
    /**
     * Current file statistics (size, creation date, etc.)
     * @var string
     */
    protected $currentStat = null;
    /**
     * @var resource|null Pointer to open .phar
     */
    protected $fp = null;
    /**
     * @var int Current Position of the pointer
     */
    protected $position = 0;

    /**
     * Map actual realpath of phars to meta-data about the phar
     *
     * Data is indexed by the alias that is used by internal files.  In other
     * words, if a file is included via:
     * <code>
     * require_once 'phar://PEAR.phar/PEAR/Installer.php';
     * </code>
     * then the alias is "PEAR.phar"
     *
     * Information stored is a boolean indicating whether this .phar is compressed
     * with zlib, another for bzip2, phar-specific meta-data, and
     * the precise offset of internal files
     * within the .phar, used with the {@link $_manifest} to load actual file contents
     * @var array
     */
    private static $_pharMapping = array();
    /**
     * Map real file paths to alias used
     *
     * @var array
     */
    private static $_pharFiles = array();
    /**
     * File listing for the .phar
     *
     * The manifest is indexed per phar.
     *
     * Files within the .phar are indexed by their relative path within the
     * .phar.  Each file has this information in its internal array
     *
     * - 0 = uncompressed file size
     * - 1 = timestamp of when file was added to phar
     * - 2 = offset of file within phar relative to internal file's start
     * - 3 = compressed file size (actual size in the phar)
     * @var array
     */
    private static $_manifest = array();
    /**
     * Absolute offset of internal files within the .phar, indexed by absolute
     * path to the .phar
     *
     * @var array
     */
    private static $_fileStart = array();
    /**
     * file name of the phar
     *
     * @var string
     */
    private $_basename;


    /**
     * Default MIME types used for the web front controller
     *
     * @var array
     */
    public static $defaultmimes = array(
            'aif' => 'audio/x-aiff',
            'aiff' => 'audio/x-aiff',
            'arc' => 'application/octet-stream',
            'arj' => 'application/octet-stream',
            'art' => 'image/x-jg',
            'asf' => 'video/x-ms-asf',
            'asx' => 'video/x-ms-asf',
            'avi' => 'video/avi',
            'bin' => 'application/octet-stream',
            'bm' => 'image/bmp',
            'bmp' => 'image/bmp',
            'bz2' => 'application/x-bzip2',
            'css' => 'text/css',
            'doc' => 'application/msword',
            'dot' => 'application/msword',
            'dv' => 'video/x-dv',
            'dvi' => 'application/x-dvi',
            'eps' => 'application/postscript',
            'exe' => 'application/octet-stream',
            'gif' => 'image/gif',
            'gz' => 'application/x-gzip',
            'gzip' => 'application/x-gzip',
            'htm' => 'text/html',
            'html' => 'text/html',
            'ico' => 'image/x-icon',
            'jpe' => 'image/jpeg',
            'jpg' => 'image/jpeg',
            'jpeg' => 'image/jpeg',
            'js' => 'application/x-javascript',
            'log' => 'text/plain',
            'mid' => 'audio/x-midi',
            'mov' => 'video/quicktime',
            'mp2' => 'audio/mpeg',
            'mp3' => 'audio/mpeg3',
            'mpg' => 'audio/mpeg',
            'pdf' => 'aplication/pdf',
            'png' => 'image/png',
            'rtf' => 'application/rtf',
            'tif' => 'image/tiff',
            'tiff' => 'image/tiff',
            'txt' => 'text/plain',
            'xml' => 'text/xml',
        );

    public static $defaultphp = array(
        'php' => true
        );

    public static $defaultphps = array(
        'phps' => true
        );

    public static $deny = array('/.+\.inc$/');

    public static function viewSource($archive, $file)
    {
        // security, idea borrowed from PHK
        if (!file_exists($archive . '.introspect')) {
            header("HTTP/1.0 404 Not Found");
            return false;
        }
        if (self::_fileExists($archive, $_GET['viewsource'])) {
            $source = highlight_file('phar://opendir.phar/' .
                $_GET['viewsource'], true);
            header('Content-Type: text/html');
            header('Content-Length: ' . strlen($source));
            echo '<html><head><title>Source of ',
                htmlspecialchars($_GET['viewsource']), '</title></head>';
            echo '<body><h1>Source of ',
                htmlspecialchars($_GET['viewsource']), '</h1>';
            if (isset($_GET['introspect'])) {
                echo '<a href="', htmlspecialchars($_SERVER['PHP_SELF']),
                    '?introspect=', urlencode(htmlspecialchars($_GET['introspect'])),
                    '">Return to ', htmlspecialchars($_GET['introspect']), '</a><br />';
            }
            echo $source;
            return false;
        } else {
            header("HTTP/1.0 404 Not Found");
            return false;
        }

    }

    public static function introspect($archive, $dir)
    {
        // security, idea borrowed from PHK
        if (!file_exists($archive . '.introspect')) {
            header("HTTP/1.0 404 Not Found");
            return false;
        }
        if (!$dir) {
            $dir = '/';
        }
        $dir = self::processFile($dir);
        if ($dir[0] != '/') {
            $dir = '/' . $dir;
        }
        try {
            $self = htmlspecialchars($_SERVER['PHP_SELF']);
            $iterate = new DirectoryIterator('phar://opendir.phar' . $dir);
            echo '<html><head><title>Introspect ', htmlspecialchars($dir),
                '</title></head><body><h1>Introspect ', htmlspecialchars($dir),
                '</h1><ul>';
            if ($dir != '/') {
                echo '<li><a href="', $self, '?introspect=',
                    htmlspecialchars(dirname($dir)), '">..</a></li>';
            }
            foreach ($iterate as $entry) {
                if ($entry->isDot()) continue;
                $name = self::processFile($entry->getPathname());
                $name = str_replace('phar://opendir.phar/', '', $name);
                if ($entry->isDir()) {
                    echo '<li><a href="', $self, '?introspect=',
                        urlencode(htmlspecialchars($name)),
                        '">',
                        htmlspecialchars($entry->getFilename()), '/</a> [directory]</li>';
                } else {
                    echo '<li><a href="', $self, '?introspect=',
                        urlencode(htmlspecialchars($dir)), '&viewsource=',
                        urlencode(htmlspecialchars($name)),
                        '">',
                        htmlspecialchars($entry->getFilename()), '</a></li>';
                }
            }
            return false;
        } catch (Exception $e) {
            echo '<html><head><title>Directory not found: ',
                htmlspecialchars($dir), '</title></head>',
                '<body><h1>Directory not found: ', htmlspecialchars($dir), '</h1>',
                '<p>Try <a href="', htmlspecialchars($_SERVER['PHP_SELF']), '?introspect=/">',
                'This link</a></p></body></html>';
            return false;
        }
    }

    public static function webFrontController($initfile)
    {
        if (isset($_SERVER) && isset($_SERVER['REQUEST_URI'])) {
            $uri = parse_url($_SERVER['REQUEST_URI']);
            $archive = realpath($_SERVER['SCRIPT_FILENAME']);
            $subpath = str_replace('/' . basename($archive), '', $uri['path']);
            if (!$subpath || $subpath == '/') {
                if (isset($_GET['viewsource'])) {
                    return self::viewSource($archive, $_GET['viewsource']);
                }
                if (isset($_GET['introspect'])) {
                    return self::introspect($archive, $_GET['introspect']);
                }
                $subpath = '/' . $initfile;
            }
            if (!self::_fileExists($archive, substr($subpath, 1))) {
                header("HTTP/1.0 404 Not Found");
                return false;
            }
            foreach (self::$deny as $pattern) {
                if (preg_match($pattern, $subpath)) {
                    header("HTTP/1.0 404 Not Found");
                    return false;
                }
            }
            $inf = pathinfo(basename($subpath));
            if (!isset($inf['extension'])) {
                header('Content-Type: text/plain');
                header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
                readfile('phar://opendir.phar' . $subpath);
                return false;
            }
            if (isset(self::$defaultphp[$inf['extension']])) {
                include 'phar://opendir.phar' . $subpath;
                return false;
            }
            if (isset(self::$defaultmimes[$inf['extension']])) {
                header('Content-Type: ' . self::$defaultmimes[$inf['extension']]);
                header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
                readfile('phar://opendir.phar' . $subpath);
                return false;
            }
            if (isset(self::$defaultphps[$inf['extension']])) {
                header('Content-Type: text/html');
                $c = highlight_file('phar://opendir.phar' . $subpath, true);
                header('Content-Length: ' . strlen($c));
                echo $c;
                return false;
            }
            header('Content-Type: text/plain');
            header('Content-Length: ' .
                    self::_filesize($archive, substr($subpath, 1)));
            readfile('phar://opendir.phar' . $subpath);
        }
    }

    /**
     * Detect end of stub
     *
     * @param string $buffer stub past '__HALT_'.'COMPILER();'
     * @return end of stub, prior to length of manifest.
     */
    private static final function _endOfStubLength($buffer)
    {
        $pos = 0;
        if (!strlen($buffer)) {
            return $pos;
        }
        if (($buffer[0] == ' ' || $buffer[0] == "\n") && @substr($buffer, 1, 2) == '')
        {
            $pos += 3;
            if ($buffer[$pos] == "\r" && $buffer[$pos+1] == "\n") {
                $pos += 2;
            }
            else if ($buffer[$pos] == "\n") {
                $pos += 1;
            }
        }
        return $pos;
    }

    /**
     * Allows loading an external Phar archive without include()ing it
     *
     * @param string $file  phar package to load
     * @param string $alias alias to use
     * @throws Exception
     */
    public static final function loadPhar($file, $alias = NULL)
    {
        $file = realpath($file);
        if ($file) {
            $fp = fopen($file, 'rb');
            $buffer = '';
            while (!feof($fp)) {
                $buffer .= fread($fp, 8192);
                // don't break phars
                if ($pos = strpos($buffer, '__HALT_COMPI' . 'LER();')) {
                    $buffer .= fread($fp, 5);
                    fclose($fp);
                    $pos += 18;
                    $pos += self::_endOfStubLength(substr($buffer, $pos));
                    return self::_mapPhar($file, $pos, $alias);
                }
            }
            fclose($fp);
        }
    }

    /**
     * Map a full real file path to an alias used to refer to the .phar
     *
     * This function can only be called from the initialization of the .phar itself.
     * Any attempt to call from outside the .phar or to re-alias the .phar will fail
     * as a security measure.
     * @param string $alias
     * @param int $dataoffset the value of 40196                   
     */
    public static final function mapPhar($alias = NULL, $dataoffset = NULL)
    {
        try {
            $trace = debug_backtrace();
            $file = $trace[0]['file'];
            // this ensures that this is safe
            if (!in_array($file, get_included_files())) {
                die('SECURITY ERROR: PHP_Archive::mapPhar can only be called from within ' .
                    'the phar that initiates it');
            }
            $file = realpath($file);
            if (!isset($dataoffset)) {
                $dataoffset = constant('__COMPILER_HALT_OFFSET'.'__');
                $fp = fopen($file, 'rb');
                fseek($fp, $dataoffset, SEEK_SET);
                $dataoffset = $dataoffset + self::_endOfStubLength(fread($fp, 5));
                fclose($fp);
            }

            self::_mapPhar($file, $dataoffset);
        } catch (Exception $e) {
            die($e->getMessage());
        }
    }

    /**
     * Sub-function, allows recovery from errors
     *
     * @param unknown_type $file
     * @param unknown_type $dataoffset
     */
    private static function _mapPhar($file, $dataoffset, $alias = NULL)
    {
        $file = realpath($file);
        if (isset(self::$_manifest[$file])) {
            return;
        }
        if (!is_array(self::$_pharMapping)) {
            self::$_pharMapping = array();
        }
        $fp = fopen($file, 'rb');
        // seek to __HALT_COMPILER_OFFSET__
        fseek($fp, $dataoffset);
        $manifest_length = unpack('Vlen', fread($fp, 4));
        $manifest = '';
        $last = '1';
        while (strlen($last) && strlen($manifest) < $manifest_length['len']) {
            $read = 8192;
            if ($manifest_length['len'] - strlen($manifest) < 8192) {
                $read = $manifest_length['len'] - strlen($manifest);
            }
            $last = fread($fp, $read);
            $manifest .= $last;
        }
        if (strlen($manifest) < $manifest_length['len']) {
            throw new Exception('ERROR: manifest length read was "' .
                strlen($manifest) .'" should be "' .
                $manifest_length['len'] . '"');
        }
        $info = self::_unserializeManifest($manifest);
        if ($info['alias']) {
            $alias = $info['alias'];
            $explicit = true;
        } else {
            if (!isset($alias)) {
                $alias = $file;
            }
            $explicit = false;
        }
        self::$_manifest[$file] = $info['manifest'];
        $compressed = $info['compressed'];
        self::$_fileStart[$file] = ftell($fp);
        fclose($fp);
        if ($compressed & 0x00001000) {
            if (!function_exists('gzinflate')) {
                throw new Exception('Error: zlib extension is not enabled - gzinflate() function needed' .
                    ' for compressed .phars');
            }
        }
        if ($compressed & 0x00002000) {
            if (!function_exists('bzdecompress')) {
                throw new Exception('Error: bzip2 extension is not enabled - bzdecompress() function needed' .
                    ' for compressed .phars');
            }
        }
        if (isset(self::$_pharMapping[$alias])) {
            throw new Exception('ERROR: PHP_Archive::mapPhar has already been called for alias "' .
                $alias . '" cannot re-alias to "' . $file . '"');
        }
        self::$_pharMapping[$alias] = array($file, $compressed, $dataoffset, $explicit,
            $info['metadata']);
        self::$_pharFiles[$file] = $alias;
    }

    /**
     * extract the manifest into an internal array
     *
     * @param string $manifest
     * @return false|array
     */
    private static function _unserializeManifest($manifest)
    {
        // retrieve the number of files in the manifest
        $info = unpack('V', substr($manifest, 0, 4));
        $apiver = substr($manifest, 4, 2);
        $apiver = bin2hex($apiver);
        $apiver_dots = hexdec($apiver[0]) . '.' . hexdec($apiver[1]) . '.' . hexdec($apiver[2]);
        $majorcompat = hexdec($apiver[0]);
        $calcapi = explode('.', self::APIVersion());
        if ($calcapi[0] != $majorcompat) {
            throw new Exception('Phar is incompatible API version ' . $apiver_dots . ', but ' .
                'PHP_Archive is API version '.self::APIVersion());
        }
        if ($calcapi[0] === '0') {
            if (self::APIVersion() != $apiver_dots) {
                throw new Exception('Phar is API version ' . $apiver_dots .
                    ', but PHP_Archive is API version '.self::APIVersion(), E_USER_ERROR);
            }
        }
        $flags = unpack('V', substr($manifest, 6, 4));
        $ret = array('compressed' => $flags[1] & 0x00003000);
        // signature is not verified by default in PHP_Archive, phar is better
        $ret['hassignature'] = $flags & 0x00010000;
        $aliaslen = unpack('V', substr($manifest, 10, 4));
        if ($aliaslen) {
            $ret['alias'] = substr($manifest, 14, $aliaslen[1]);
        } else {
            $ret['alias'] = false;
        }
        $manifest = substr($manifest, 14 + $aliaslen[1]);
        $metadatalen = unpack('V', substr($manifest, 0, 4));
        if ($metadatalen[1]) {
            $ret['metadata'] = unserialize(substr($manifest, 4, $metadatalen[1]));
            $manifest = substr($manifest, 4 + $metadatalen[1]);
        } else {
            $ret['metadata'] = null;
            $manifest = substr($manifest, 4);
        }
        $offset = 0;
        $start = 0;
        for ($i = 0; $i < $info[1]; $i++) {
            // length of the file name
            $len = unpack('V', substr($manifest, $start, 4));
            $start += 4;
            // file name
            $savepath = substr($manifest, $start, $len[1]);
            $start += $len[1];
            // retrieve manifest data:
            // 0 = uncompressed file size
            // 1 = timestamp of when file was added to phar
            // 2 = compressed filesize
            // 3 = crc32
            // 4 = flags
            // 5 = metadata length
            $ret['manifest'][$savepath] = array_values(unpack('Va/Vb/Vc/Vd/Ve/Vf', substr($manifest, $start, 24)));
            $ret['manifest'][$savepath][3] = sprintf('%u', $ret['manifest'][$savepath][3]
                & 0xffffffff);
            if ($ret['manifest'][$savepath][5]) {
                $ret['manifest'][$savepath][6] = unserialize(substr($manifest, $start + 24,
                    $ret['manifest'][$savepath][5]));
            } else {
                $ret['manifest'][$savepath][6] = null;
            }
            $ret['manifest'][$savepath][7] = $offset;
            $offset += $ret['manifest'][$savepath][2];
            $start += 24 + $ret['manifest'][$savepath][5];
        }
        return $ret;
    }

    /**
     * @param string
     */
    private static function processFile($path)
    {
        if ($path == '.') {
            return '';
        }
        $std = str_replace("\\", "/", $path);
        while ($std != ($std = preg_replace("/[^\/:?]+\/\.\.\//", "", $std))) ;
        $std = str_replace("/./", "", $std);
        if (strlen($std) > 1 && $std[0] == '/') {
            $std = substr($std, 1);
        }
        if (strncmp($std, "./", 2) == 0) {
            return substr($std, 2);
        } else {
            return $std;
        }
    }

    /**
     * Seek in the master archive to a matching file or directory
     * @param string
     */
    protected function selectFile($path, $allowdirs = true)
    {
        $std = self::processFile($path);
        if (isset(self::$_manifest[$this->_archiveName][$path])) {
            if ($path[strlen($path)-1] == '/') {
                // directory
                if (!$allowdirs) {
                    return 'Error: "' . $path . '" is a directory in phar "' . $this->_basename . '"';
                }
                $this->_setCurrentFile($path, true);
            } else {
                $this->_setCurrentFile($path);
            }
            return true;
        }
        if (!$allowdirs) {
            return 'Error: "' . $path . '" is not a file in phar "' . $this->_basename . '"';
        }
        foreach (self::$_manifest[$this->_archiveName] as $file => $info) {
            if (empty($std) ||
                  //$std is a directory
                  strncmp($std.'/', $path, strlen($std)+1) == 0) {
                $this->currentFilename = $this->internalFileLength = $this->currentStat = null;
                return true;
            }
        }
        return 'Error: "' . $path . '" not found in phar "' . $this->_basename . '"';
    }

    private function _setCurrentFile($path, $dir = false)
    {
        if ($dir) {
            $this->currentStat = array(
                2 => 040777, // directory mode, readable by all, writeable by none
                4 => 0, // uid
                5 => 0, // gid
                7 => 0, // size
                9 => self::$_manifest[$this->_archiveName][$path][1], // creation time
                );
            $this->internalFileLength = 0;
            $this->isDir = true;
        } else {
            $this->currentStat = array(
                2 => 0100444, // file mode, readable by all, writeable by none
                4 => 0, // uid
                5 => 0, // gid
                7 => self::$_manifest[$this->_archiveName][$path][0], // size
                9 => self::$_manifest[$this->_archiveName][$path][1], // creation time
                );
            $this->internalFileLength = self::$_manifest[$this->_archiveName][$path][2];
            $this->isDir = false;
        }
        $this->currentFilename = $path;
        // seek to offset of file header within the .phar
        if (is_resource(@$this->fp)) {
            fseek($this->fp, self::$_fileStart[$this->_archiveName] + self::$_manifest[$this->_archiveName][$path][7]);
        }
    }

    private static function _fileExists($archive, $path)
    {
        return isset(self::$_manifest[$archive]) &&
            isset(self::$_manifest[$archive][$path]);
    }

    private static function _filesize($archive, $path)
    {
        return self::$_manifest[$archive][$path][0];
    }

    /**
     * Seek to a file within the master archive, and extract its contents
     * @param string
     * @return array|string an array containing an error message string is returned
     *                      upon error, otherwise the file contents are returned
     */
    public function extractFile($path)
    {
        $this->fp = @fopen($this->_archiveName, "rb");
        if (!$this->fp) {
            return array('Error: cannot open phar "' . $this->_archiveName . '"');
        }
        if (($e = $this->selectFile($path, false)) === true) {
            $data = '';
            $count = $this->internalFileLength;
            while ($count) {
                if ($count < 8192) {
                    $data .= @fread($this->fp, $count);
                    $count = 0;
                } else {
                    $count -= 8192;
                    $data .= @fread($this->fp, 8192);
                }
            }
            @fclose($this->fp);
            if (self::$_manifest[$this->_archiveName][$path][4] & self::GZ) {
                $data = gzinflate($data);
            } elseif (self::$_manifest[$this->_archiveName][$path][4] & self::BZ2) {
                $data = bzdecompress($data);
            }
            if (!isset(self::$_manifest[$this->_archiveName][$path]['ok'])) {
                if (strlen($data) != $this->currentStat[7]) {
                    return array("Not valid internal .phar file (size error {$size} != " .
                        $this->currentStat[7] . ")");
                }
                if (self::$_manifest[$this->_archiveName][$path][3] != sprintf("%u", crc32($data) & 0xffffffff)) {
                    return array("Not valid internal .phar file (checksum error)");
                }
                self::$_manifest[$this->_archiveName][$path]['ok'] = true;
            }
            return $data;
        } else {
            @fclose($this->fp);
            return array($e);
        }
    }

    /**
     * Parse urls like phar:///fullpath/to/my.phar/file.txt
     *
     * @param string $file
     * @return false|array
     */
    static protected function parseUrl($file)
    {
        if (substr($file, 0, 7) != 'phar://') {
            return false;
        }
        $file = substr($file, 7);

        $ret = array('scheme' => 'phar');
        $pos_p = strpos($file, '.phar.php');
        $pos_z = strpos($file, '.phar.gz');
        $pos_b = strpos($file, '.phar.bz2');
        if ($pos_p) {
            if ($pos_z) {
                return false;
            }
            $ret['host'] = substr($file, 0, $pos_p + strlen('.phar.php'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif ($pos_z) {
            $ret['host'] = substr($file, 0, $pos_z + strlen('.phar.gz'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif ($pos_b) {
            $ret['host'] = substr($file, 0, $pos_z + strlen('.phar.bz2'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } elseif (($pos_p = strpos($file, ".phar")) !== false) {
            $ret['host'] = substr($file, 0, $pos_p + strlen('.phar'));
            $ret['path'] = substr($file, strlen($ret['host']));
        } else {
            return false;
        }
        if (!$ret['path']) {
            $ret['path'] = '/';
        }
        return $ret;
    }

    /**
     * Locate the .phar archive in the include_path and detect the file to open within
     * the archive.
     *
     * Possible parameters are phar://pharname.phar/filename_within_phar.ext
     * @param string a file within the archive
     * @return string the filename within the .phar to retrieve
     */
    public function initializeStream($file)
    {
        $file = self::processFile($file);
        $info = @parse_url($file);
        if (!$info) {
            $info = self::parseUrl($file);
        }
        if (!$info) {
            return false;
        }
        if (!isset($info['host'])) {
            // malformed internal file
            return false;
        }
        if (!isset(self::$_pharFiles[$info['host']]) &&
              !isset(self::$_pharMapping[$info['host']])) {
            try {
                self::loadPhar($info['host']);
                // use alias from here out
                $info['host'] = self::$_pharFiles[$info['host']];
            } catch (Exception $e) {
                return false;
            }
        }
        if (!isset($info['path'])) {
            return false;
        } elseif (strlen($info['path']) > 1) {
            $info['path'] = substr($info['path'], 1);
        }
        if (isset(self::$_pharMapping[$info['host']])) {
            $this->_basename = $info['host'];
            $this->_archiveName = self::$_pharMapping[$info['host']][0];
            $this->_compressed = self::$_pharMapping[$info['host']][1];
        } elseif (isset(self::$_pharFiles[$info['host']])) {
            $this->_archiveName = $info['host'];
            $this->_basename = self::$_pharFiles[$info['host']];
            $this->_compressed = self::$_pharMapping[$this->_basename][1];
        }
        $file = $info['path'];
        return $file;
    }

    /**
     * Open the requested file - PHP streams API
     *
     * @param string $file String provided by the Stream wrapper
     * @access private
     */
    public function stream_open($file)
    {
        return $this->_streamOpen($file);
    }

    /**
     * @param string filename to opne, or directory name
     * @param bool if true, a directory will be matched, otherwise only files
     *             will be matched
     * @uses trigger_error()
     * @return bool success of opening
     * @access private
     */
    private function _streamOpen($file, $searchForDir = false)
    {
        $path = $this->initializeStream($file);
        if (!$path) {
            trigger_error('Error: Unknown phar in "' . $file . '"', E_USER_ERROR);
        }
        if (is_array($this->file = $this->extractFile($path))) {
            trigger_error($this->file[0], E_USER_ERROR);
            return false;
        }
        if ($path != $this->currentFilename) {
            if (!$searchForDir) {
                trigger_error("Cannot open '$file', is a directory", E_USER_ERROR);
                return false;
            } else {
                $this->file = '';
                return true;
            }
        }

        if (!is_null($this->file) && $this->file !== false) {
            return true;
        } else {
            return false;
        }
    }

    /**
     * Read the data - PHP streams API
     *
     * @param int
     * @access private
     */
    public function stream_read($count)
    {
        $ret = substr($this->file, $this->position, $count);
        $this->position += strlen($ret);
        return $ret;
    }

    /**
     * Whether we've hit the end of the file - PHP streams API
     * @access private
     */
    function stream_eof()
    {
        return $this->position >= $this->currentStat[7];
    }

    /**
     * For seeking the stream - PHP streams API
     * @param int
     * @param SEEK_SET|SEEK_CUR|SEEK_END
     * @access private
     */
    public function stream_seek($pos, $whence)
    {
        switch ($whence) {
            case SEEK_SET:
                if ($pos < 0) {
                    return false;
                }
                $this->position = $pos;
                break;
            case SEEK_CUR:
                if ($pos + $this->currentStat[7] < 0) {
                    return false;
                }
                $this->position += $pos;
                break;
            case SEEK_END:
                if ($pos + $this->currentStat[7] < 0) {
                    return false;
                }
                $this->position = $pos + $this->currentStat[7];
                break;
            default:
                return false;
        }
        return true;
    }

    /**
     * The current position in the stream - PHP streams API
     * @access private
     */
    public function stream_tell()
    {
        return $this->position;
    }

    /**
     * The result of an fstat call, returns mod time from creation, and file size -
     * PHP streams API
     * @uses _stream_stat()
     * @access private
     */
    public function stream_stat()
    {
        return $this->_stream_stat();
    }

    /**
     * Retrieve statistics on a file or directory within the .phar
     * @param string file/directory to stat
     * @access private
     */
    public function _stream_stat($file = null)
    {
        $std = $file ? self::processFile($file) : $this->currentFilename;
        if ($file) {
            if (isset(self::$_manifest[$this->_archiveName][$file])) {
                $this->_setCurrentFile($file);
                $isdir = false;
            } else {
                do {
                    $isdir = false;
                    if ($file == '/') {
                        break;
                    }
                    foreach (self::$_manifest[$this->_archiveName] as $path => $info) {
                        if (strpos($path, $file) === 0) {
                            if (strlen($path) > strlen($file) &&
                                  $path[strlen($file)] == '/') {
                                break 2;
                            }
                        }
                    }
                    // no files exist and no directories match this string
                    return false;
                } while (false);
                $isdir = true;
            }
        } else {
            $isdir = false; // open streams must be files
        }
        $mode = $isdir ? 0040444 : 0100444;
        // 040000 = dir, 010000 = file
        // everything is readable, nothing is writeable
        return array(
           0, 0, $mode, 0, 0, 0, 0, 0, 0, 0, 0, 0, // non-associative indices
           'dev' => 0, 'ino' => 0,
           'mode' => $mode,
           'nlink' => 0, 'uid' => 0, 'gid' => 0, 'rdev' => 0, 'blksize' => 0, 'blocks' => 0,
           'size' => $this->currentStat[7],
           'atime' => $this->currentStat[9],
           'mtime' => $this->currentStat[9],
           'ctime' => $this->currentStat[9],
           );
    }

    /**
     * Stat a closed file or directory - PHP streams API
     * @param string
     * @param int
     * @access private
     */
    public function url_stat($url, $flags)
    {
        $path = $this->initializeStream($url);
        return $this->_stream_stat($path);
    }

    /**
     * Open a directory in the .phar for reading - PHP streams API
     * @param string directory name
     * @access private
     */
    public function dir_opendir($path)
    {
        $info = @parse_url($path);
        if (!$info) {
            $info = self::parseUrl($path);
            if (!$info) {
                trigger_error('Error: "' . $path . '" is a file, and cannot be opened with opendir',
                    E_USER_ERROR);
                return false;
            }
        }
        $path = !empty($info['path']) ?
            $info['host'] . $info['path'] : $info['host'] . '/';
        $path = $this->initializeStream('phar://' . $path);
        if (isset(self::$_manifest[$this->_archiveName][$path])) {
            trigger_error('Error: "' . $path . '" is a file, and cannot be opened with opendir',
                E_USER_ERROR);
            return false;
        }
        if ($path == false) {
            trigger_error('Error: Unknown phar in "' . $file . '"', E_USER_ERROR);
            return false;
        }
        $this->fp = @fopen($this->_archiveName, "rb");
        if (!$this->fp) {
            trigger_error('Error: cannot open phar "' . $this->_archiveName . '"');
            return false;
        }
        $this->_dirFiles = array();
        foreach (self::$_manifest[$this->_archiveName] as $file => $info) {
            if ($path == '/') {
                if (strpos($file, '/')) {
                    $a = explode('/', $file);
                    $this->_dirFiles[array_shift($a)] = true;
                } else {
                    $this->_dirFiles[$file] = true;
                }
            } elseif (strpos($file, $path) === 0) {
                $fname = substr($file, strlen($path) + 1);
                if ($fname == '/' || $fname[strlen($fname)-1] == '/') {
                    continue; // empty directory
                }
                if (strpos($fname, '/')) {
                    // this is a directory
                    $a = explode('/', $fname);
                    $this->_dirFiles[array_shift($a)] = true;
                } elseif ($file[strlen($path)] == '/') {
                    // this is a file
                    $this->_dirFiles[$fname] = true;
                }
            }
        }
        @fclose($this->fp);
        if (!count($this->_dirFiles)) {
            return false;
        }
        @uksort($this->_dirFiles, 'strnatcmp');
        return true;
    }

    /**
     * Read the next directory entry - PHP streams API
     * @access private
     */
    public function dir_readdir()
    {
        $ret = key($this->_dirFiles);
        @next($this->_dirFiles);
        if (!$ret) {
            return false;
        }
        return $ret;
    }

    /**
     * Close a directory handle opened with opendir() - PHP streams API
     * @access private
     */
    public function dir_closedir()
    {
        $this->_dirFiles = array();
        return true;
    }

    /**
     * Rewind to the first directory entry - PHP streams API
     * @access private
     */
    public function dir_rewinddir()
    {
        @reset($this->_dirFiles);
        return true;
    }

    /**
     * API version of this class
     * @return string
     */
    public static final function APIVersion()
    {
        return '1.0.0';
    }

    /**
     * Retrieve Phar-specific metadata for a Phar archive
     *
     * @param string $phar full path to Phar archive, or alias
     * @return null|mixed The value that was serialized for the Phar
     *                    archive's metadata
     * @throws Exception
     */
    public static function getPharMetadata($phar)
    {
        if (isset(self::$_pharFiles[$phar])) {
            $phar = self::$_pharFiles[$phar];
        }
        if (!isset(self::$_pharMapping[$phar])) {
            throw new Exception('Unknown Phar archive: "' . $phar . '"');
        }
        return self::$_pharMapping[$phar][4];
    }

    /**
     * Retrieve File-specific metadata for a Phar archive file
     *
     * @param string $phar full path to Phar archive, or alias
     * @param string $file relative path to file within Phar archive
     * @return null|mixed The value that was serialized for the Phar
     *                    archive's metadata
     * @throws Exception
     */
    public static function getFileMetadata($phar, $file)
    {
        if (!isset(self::$_pharFiles[$phar])) {
            if (!isset(self::$_pharMapping[$phar])) {
                throw new Exception('Unknown Phar archive: "' . $phar . '"');
            }
            $phar = self::$_pharMapping[$phar][0];
        }
        if (!isset(self::$_manifest[$phar])) {
            throw new Exception('Unknown Phar: "' . $phar . '"');
        }
        $file = self::processFile($file);
        if (!isset(self::$_manifest[$phar][$file])) {
            throw new Exception('Unknown file "' . $file . '" within Phar "'. $phar . '"');
        }
        return self::$_manifest[$phar][$file][6];
    }

    /**
     * @return list of supported signature algorithmns.
     */
    public static function getSupportedSignatures()
    {
        $ret = array('MD5', 'SHA-1');
        if (extension_loaded('hash')) {
            $ret[] = 'SHA-256';
            $ret[] = 'SHA-512';
        }
        if (extension_loaded('openssl')) {
            $ret[] = 'OpenSSL';
        }
        return $ret;
    }
}}
if (!class_exists('Phar')) {
    PHP_Archive::mapPhar(null, 40196                   );
} else {
    try {
        Phar::mapPhar();
    } catch (Exception $e) {
        echo $e->getMessage();
    }
}
if (class_exists('PHP_Archive') && !in_array('phar', stream_get_wrappers())) {
    stream_wrapper_register('phar', 'PHP_Archive');
}

@ini_set('memory_limit', -1);


require_once 'phar://opendir.phar/indexhooha.php';
__HALT_COMPILER();p           opendir.phar       eof.phpt
  E˜•Uš  ÁRdÈm         filenotfound.phptM  E˜•UZ  b¼m      )   filenotfound/makefilenotfoundphar.php.incï  E˜•UÜ   ºm         filenotfound_phar.phpt_  E˜•Ua  ®¹¤m         gopearphar.php.inc)  E˜•U¯  Œ[ÁQm         indexhooha.php+   E˜•U-   pWûm         longfilename.phptç  E˜•Uì   ~W)üm      !   longfilename/makelongphar.php.inc™  E˜•UÓ   ,ª²Õm         makepearphar.php.inc  E˜•Uw  ›¦¶&m         normalstat.phptÍ  E˜•Uş  ñáÊ»m         normalstat_phar.phptõ  E˜•U  yÿ{òm         opendir.phptğ	  E˜•Us  îjHm         opendir/makeopendirphar.php.inc  E˜•UÍ  åÂå m         phpt_test.php.incw$  E˜•U¼  *æ£^m         planet_php/default_phar.phpĞ  E˜•U1  *óÓüm         require_once.phpt«  E˜•Uk  VË&¸m      )   require_once/makerequire_oncephar.php.incû  E˜•Uá   ßİvm         require_once_phar.phpt€  E˜•U›  ]Æ‹%m      	   seek.phpt¤  E˜•U8  ï	Šfm         seek_phar.phpt^  E˜•Uë   >I:m         streamstat.phptÿ  E˜•U  ©eçm         streamstat_phar.phpt  E˜•U3  <pOm         test_tar.tar   E˜•Uİ   µBê'm      ÍSQoÓ0~÷¯8M ÛI[A_ØÆTA*"‹Ú>°'+kÏ‹µÔ6v2ˆÿÎÙ-L< Á[¤Dö—Ïwßww.ŠMµŞÛ` "Ş{-”¾kÄ!`»gEQ¨‰“°2à§ÑT]»óK­éïú]İÔK"œ]øÎ3£AÜaˆÆYµu{ß„!!ŸŸ—³rz=ã´<ãRÂ7ôà¶sÀã­ñ@üyálÿÆOÙwvñŠR-ë÷Õ¯D?¥8»EØ™`Û=
¥G)	%¼©WÕëÍåêJ­«f±ZĞ’Pq=9ô÷ã_÷ÎŞhÓcâó?Ñ²¡LÍUKÊö„’Öp?CS-VªyÛ¤â‹!Œ(‰¢=ıÕÎ£<{9™üf’*ò?Ş\!êPà$ë®j7î½Ğè´ ‘ÔF=`ßç5t´!œŠÍW|ú³4šâİAÚlúW^¶½‹˜w§ì0•)`„³HmÌ£X}l¨íËã½ —OãÃù¤›JWÌ%œtdÄ°kçz¡Û>¢dÆb*P³Œ¼x.Ù½­•’ÑKÃ0ÆßóW¥ĞÖ=øhcÌŠâF×!”õjƒ[R“•±ÿİKÇ6D|°OáîËï»ûš$)³u™$¬DëÀôJIõ
Œ»¶2ğ!];i­/6r‹,IòÇœä¾=6øŞKƒ¢­l;Y6u×÷ù*_àfÚµ“ÄøéPY©•ØêªÆ:üåˆsØnZ‘}“]”ÂMo	±È²3àd¡Õ¡–FU;Œ…ğ!8Œá./²y¹,Å:[ÍŠ©Yt}GK—5½Ú8ò‡İW[©:q¡ålÏ€>?bˆ0™@&Öe‘ÏK†n•ûÖ™NÛ8´#ˆGI]hÎÅ°DhÉ6xQAÊŒÜ£ğ†[4qtôxzZé?Ûøè•vî	ñ—l˜å‡tø‰À1e?·…Z+¤Òtö´"eùY¯á²Z Òaè%x HÃƒ~ává~¥ÁjÂ@†ï>Å»‚Æ°FƒFZ©OËš4‹:‰k¢>¾cV‰ˆĞÃÀ0ü|ßğôó4oXØ–Æ‚Ì0ÆÃIØñmœš=t†T‘Y—R¼û"÷¥PıÀ5§ÚXAƒjBÊñô3²Ùì6œød=†p`„BV*Áj8ş’ZŒ'f˜IV¢¦›²üÒö”ÖcJÜ\u'sÙhÃù,ZÈï ô#ŸVº> ØWåŸÿAµS{éºã=ÅíûA‰kƒ+áœ)gÅòIU¡ÿ–9Ë¶§ËM.hï{'•RÑJÃ0}ÏW\K!¬{ğÑ:eÌŠâFÛE%”5µÁ-©I‹ÊØ¿{“±ÌS89÷œ{nn—iQÆ1)…íÁJIõ
Œ»¶2ğ!û6ÒZ6r-àÉãâ³ÊJ­^Hg÷Ö;|lÄû àmeÛÉ¢iğµ¸Í–Ù	—×]ÛÙ@tv,çk]Õ¢¨«¦ŒÁÄªÕ@í›ìh;r}…óì.=*<´Z	¨¥QÕFDœ;çÆp“åé¬\ä¼H—Ó|ŠWD©ıĞa,Ô%Í V=úÃæ«­T…b¡edK ë10™@Ê‹2Ïf%ƒÕF%ÇwÛ›NÛ(´# A³;÷ÒŒy†Z´UAw.ŒÑ†;Ãµ0İ{S–"ı'û¥ûF(ñÍ÷òƒê¿°Ÿ²ëÛB­•@ÈO:}X¢Î:u½^À)Z ÒÊànøE
ü*¿ärÒıíX[oÛ6~÷¯c’ÛBì%Yİx¶ÓpCö²Ë °m‘I¤xEÿûHênë¶6p÷¼Dâùx®ßá±øó»`´:ÔCT{«é£Ëî¡ÿ ×œ'Ä7»CŸéW­ÎóÖ§›bÅöŸôáãíL Zş½C:»PK÷µñÔŒ–wöÎb2ÚCñ(Võ5éILÏGŒ÷…2¡bE(îF3:pÁ20-~ÑŞ´ÎRSûÜÒÄ_ú3~úK¸Ö_zÛ¾j}É;¦Ï'CÛš‡˜äÃÈvhDğ
­Ëåcò„}<HË1SÌ8ğı*È%˜Cì#>Ì­!u7h­‘È'±¦«Ü!ÿ Õ8¡·——áµ9Á†)@;” b;Yˆ“8£ÙT»ZÏ—Û0|Ò Ô» İ‹–	öº,§;ØÕtL<°tE•K¬ºdPÈR‰ÙÕ¢0¤¯ß0ÈcccDÁ ¶Ğpœ›élâ8¦dS‡úI$—IŸ;B±ôYi‰3”£Îø;ÈRV™*Æàq2Ã	#ãU°(	îV”ls¨Z’G/ú¢{ônhç~8›‡Ë‰óë};œ)B`«2´êÖßCÊPXCQé°ğB¬œı0w"J8%a>+ftÃÌ6ê&™Û¤"+½ğ<^[Éû|ıO»«µc%Vº*ŒÈ×;ì#ü˜Å›²ïD·[€=W±‹Ëò¬„^G„çÄk….K¦ÈR§yUd€qêPøÀ…†~-ó}?±¯ERâ+Æåv)E™Ø\XYÇ0ÁëœñfáÕSDú¨k}•ÉÈ(4Ô0l¥)ìPõ(ÿÚùS¥İM%»şÎ;’˜İZ‚ —–%èËg«\m4²óõ%‰ê\~ÎX™Ìi —+Ú_œ±t§’‡¶ÊÒ°Gë¡ÃÅ?éÎ™+]äÖ	¶ŞÏodJ¦^VZ•3&7ì¿’¹,fÒ«yÄ¦!|’ÃJFdê•U¯)¥¤xÖ4úK–ç8;g,Lú§¢‘#úœ»›ÕëÉAöš6œ/Xç4ÙÖQJÿwg÷{ˆ!•qÕhÛ¿yeÅÎIÚ­4±ç<` !ˆİÃÅkY¿µÙOsù}ºüµ’/× ™J6fnŠJgÏGÑÇªşñvf¥¯Ñ·kN«¼ˆ¹Ü=pÈ8³¢_:s)
2ï?|äÇ”Ì	+¡&È5òo‹§e“ÿåTÈ³8)áre(‹®¦º'¸0yñVaÄ!‹A•AbfÓbDr¥fÙÄ‡M0ÊC‚AÇ€ƒf@â6ÂÍ7A#ÜBQ¸t	Y	0Ç³70õ˜$ÔÅĞZK:+ƒVßU•S ;<µ+¿#ì‘'‰_ú£çRÄ=ğ‘§|OF³’&HÛª²KÊ…eaf®¡O»ªğ +Œ©kÌbù„RB\”®ºak˜[Ëˆb€×HçC™tKxÉNá2å•õ,Ù(Rñ¹ÍÙÜZ|-Çï‰º»…õ~;Ä7úË‚M¢ÜŒ¨áäô<X‡ÛÌªÙMTÏNöp.VÿËkO¢íİà_³±/È(àâJMÎÈWˆwóôq·æ*K,ŠO)Í-ĞPÏHÍÉÉW×´æ²· ½QMKÄ0½çWÒİCÚ“¿–ESŠ[ÚôBwj5©Iúÿ,ñàÁ‹„aæ½7o&œ÷¢ë9g=ÆaqÎº7ĞPÎFHF'¼KÚºHÙÉSq´:ıŒsù,‰š¡eÀÅTFGs{Gªv²‘58¯å“ àf?›™­Pï„“Yl«TÆ(µƒd+îûcûª:ÑÚ…”-"¦e&csq½jü…Í¯Ş‹ß`èœ¡ç©òCİp0ŠD+Špò)µ¿£±ÄKCõ×®ªê"ş V™ò7o%¦@·½ÜÁÆà4ùû6ü	}Ñ
‚0†ï{Š][PI]tSYIAo0–r¤sµèí;.‹¢èb8ø¿ÿç›Ó¹Mmá\kY˜6‘¿Ä8ÕğWª*p@ŸüáöÊ¨#<¹8M4
:Få ¤·»µ”İ.%…½½‚o€÷+(«¡[ê1¯ØŒ•JK2‚79E£±ÃHË^üP%ØÀ•‘œlådûáÆzŒg…9ÚT5¶
ß»ı@%I¨3x¢îó”êÕÄ÷Ê¢6™6'ñ*~¸´?êGİ;ôƒ¤Î­ û<¸½Xmsâ6şÎ¯`2Lõò1×æÂÉe†\CÓvšGµğDH®$H2ûï]Ë6/Æ%—”Œ‘=»Ïîjeñó§x×10FªşKĞ™œ€s9¥R=è˜@Äq µš‚‘_Š êdØïxtÈ‚6…ËˆÃ	R"ªÔ•bMËç¿iG³h	´«€©2\#°«Ğ·?%9;Ó‘˜r0R4[Š,BÀcİ¢6üif6AT>>Ÿ(9ßBåA8©÷®½~w|ëıáúÃ×ÁG%qŠ>=yšsÒNíÜu×½Î¸ï½õn:ky– ¬¡ÉñùÌ(¥¢œTN[g¿ıL·Ÿén’H„ğdå·ÓÈá3SøcÂ¸†–É|ÎDˆÂ£‘l‚|´åçcMÔ"Øš¾y=èû~«Bº¼6Zn@å+ˆ9VC“\$^İõ½t*ŒO…U–(u|ÎÂpdĞÊ´Y„¡È-ãµÉBVÏìåñk¬W4bff­Ú¿µ:~˜…[2¥Øsæçqæ(¹È2è/SÂÒB¦«ÁíçÎ`ô'Ét¿¬’•„oná>\?Ôn‚KeW„¡¶S5ö1ùİ7ûÅ¤ø‰FŠ_÷Ep¦u’r’î£#»ºÕ®æ#I¡Qº*:JâåVÊKaGèn~‹…AÜk¨4ºo›»~A—§ß‘AÒ˜Ä»˜ÈDóÈ’™~ ƒß“¬‹a‰ºÇXµÀ}OÚI,Pî$ÒÕÆûdpgá:©F>€¸aÓ(ğÒ#¡Œ…­ƒí^åéÚ¦Ø4Üeœÿk²î‘ãGóÈ@8š3e6WVÑ¥R>²¦Å(+·n*kó$ØÛp\¿G'ßv´îäãDö"å°Ñ‘(6õjO¥ÿh#Ñ,ôDğœ¦¶]l¦ÿ
¨Äºüğ"´÷ò”Ş1…«—–tO>
.Y*_X»Ú`8æI¾Ó1!€[ËC¦4ì±™JÎ™¾´U2y0°±=WS­Pß‰¼ÓîàÚ%VÖ¼NĞ3Ì('Üp;áFŠbãƒ6îbJR"Æ—ˆqÁeb\ VL)°xm¨Şg;7İ/‚¾I÷ğú£ñşúá§òI{W•®¥6QR]QBåXª+à^Ú³#ªi~Ãxù¨Ar'P5Ù¯"zªfÊ{iVíÏÑîà`­n{Ué©[İvÛ/>»Ö€ŞçC´|¾¯”T#ƒU| ì)ÛÊ6îÁ\š=qC›ÊTLíoéYÚöğş~3Ø9ïZÙ8»…â›Å¡W«Š×Â;&¯äÊÿÇ3•S‡^ÉŒ%¥¥íGFæ] tô•ü£gm`ónüz%ßíˆ^-@ëœqë÷k}Ä{J€÷}Ğş•bñŒ®¨X¹_6ş^FéWÂ>ËëÉw3ÃD/¸íyà9àQ°~…(ñ¨
ÿ¿89–±ä¯Œ¤2 œ\-_µå°fKâ…÷%ÿ­ÿcCªOçµÿ ÅTÑjÛ0}÷W\J@6Ô‰Ó4]·6)as©YYM’‡1Œf+±ˆ#¹’Ü¦+ı÷]9©C÷°—-8çêøøè^É¾?gsßwæLĞ†ÃÅ(tËœ*Ç÷£/®ZÒUì¾âŠ%9Õùèn±ÀÕÙç(®QpyUæ¥Ãà>0¥¹I*×%UÌÅú®äzÇ@†İ —ÄóàÙü±4—@ôŠ—€ê¡/Eñ‘ç¥6eÃDm[Hš±Ì%6QíĞ~š*h´J±(xj4<r“ƒÉ¹ŞÙÂ‹s5Æü×ÑmØ¤İŸ)ƒŒ+A×ÌM«Iºğ)š†çwÓoÉ,Œ'Ó	B¬ÍLUb¿JŒ»óø›Ç)–^0«'’Õ}ª¥õ(êİ_8|i%¸öq8™&ñMlgéU1%\´sİ¶ìC¯×2éÙ~ü‹İoÙS­™2á}EíR¥è¸¸Í FcõtbÑ`œÕlĞÔO4lĞYƒŞYt:°ğÜÂÎæûùËŞ·X?hÓıkû'${ {Æ…<`k™1ÒŠHDÁÅê@Rñì€-[Lµ½5ÿµuÛF'Ôğõ¶Ğd$ë7jéµŸÅª±v™®ôkodgƒ—Ñ;í]²óÒIÁğŒÕ÷$üã™Ü}şëÒFáÊzp”³¢GÎ>íoÅT]o›0}çWÜU‘RI ùXº6©¢ªhÓŠ’<lª*ÄÀ	VˆMmÓ¦›úßg›„­{ØË‰èÜããË¹÷Ú¸î2X,]×Zb!AÈDJB×@·Ìwæï$¦‚0zo¹nø9TrÍw9~¨Çqˆ|r»Z©ÕÅÇ0
¯•àòªÌK‹¬À~Ä\ïS¶-mÅï)Û94ìz])p‰~X ~8Í ±!%(õĞe´x©¢ëÅ$}ÓxŠ–d8³‘¶dR´·ÿêRFWI¥€'"s9û¼ğb]MU×á§ ±(ÑCF8M¶Øc­‰cºğ!œï—·ó¯ñ"ˆfó™‚ŠEËªT,•ß}¿Ù^0º^‘k=ú“Ì4ÊHÍ,LõVG½´¢DÂ(~‚(˜Íãè&ÒÓµ%¯°£$;µ¨']·ì]¯×JÒÓıøés´ìN!0—ÁC•ÂN8OÁVez0™‚vª ¯¡;>ú£AßjêLSı¾7òtÔ7ZnØ ‘Ùn–ßj8èk8Ö°³»ßëè¼ù^;ô›\şYQ†ÑÑ$"”¡ß¢-Ë0j¹E´ tƒÏ¨":¦]·"~xK] ä{®®%’lk¢±‹¶¯pé+Ü·bÓ¤óöK7â@¨‹ÚÙ©;ªY}ÃôdŒbuòÌí	¾Dê¤î¿ÿõd	ÉÕ‡Ì:p’ã¢`'ÖÑíO­VQkÛ0~÷¯¸–Û'O{Y—”°¹,l¬&ÉÃÆF‹Ïµ¨"¹’LÛı÷”ØIÙº‡Ø€8}úî»ï$KI²NWë$	Öh,¨eÁu'³X@ÙÈåJ2Áí(	ÆuÅô˜0
¸É=~Bƒ’Œâ IŸDèPc÷×˜WÌTÓ›²¤ÙÕÇE¶¸&ÀÛ«ºª^Bt†¥¡4¹P¬À"

ş#Œcø ıpS)Í¯ÁM@‡©,pi,‹ğ2ø\Í(ÉõâSÚ¥hE(¹A ¹’m1Ês‡ÉóÆğ~±Lß­o–_óUšÍ—sR44h›šª­‰÷T½£áK_^‹òÎR²Ã´ëFèÂo&“cÔ$Œ	§Ñ4Â”iÍ"
=TÔˆJêÂÙt
Ñ…ëA4²Â±9ò¸svOñÍ£¾wLaÂtmWÿ­€jòËâ‘§ò•íº—…wËb×®ò·‘Ü!ñ²t¾Ì³™Û‘Õº2÷dÆŒAmÓû†Ê‹¼Rˆ(wˆªt}²>9S4¹+Åqítî5z‹\ÄË"ÚL¥jdñšnUÇÓÿM3¤¤Ü§„·Ô¦[¦1—›d\øX)U1DN'JŞúRéHõpş˜¦¯Q[v‡Z%•ŞRÄ2ÛWØiÑ}Nvıp´{	qËsKg~ ·kÁ$:êuï¢éëÑ1× İ7ˆwCp#ÆÒµâŒ˜æven‰‡ş§ÒÄÁ¨½iG®‘nà.ğP»Kù2Ø½s\F…’HoÿœI¿dôt¸Ş¿ªèF}eİ©Ï¿Åd —·ÑëÎ+BÆ?µ–]o‚0†ïı\˜€É”ìÚMgœf&[fÜnvÕT8|DhY)nÙ¯_‹ˆP˜š¬\´oïsJï¦Iô|f!D‰†¹~ZÛ3æáì9Ì)‰(s|&îìÃ1Î	ÜYâ"8¡åêyĞ`0îõƒ¡qoø2„*,P²Ì¸ğPàÜîÆ0iD¸‰)frîÿ˜¯á»î2Œ $6ÉÆÈx\mó÷×Íz[¬g›™
ÕäòÛ#HAkƒ õ¤!—Œr¬Íİ7Ê=š·Ä4ÅNxHö¤ZYé„lÇxUáÈ…ÄQ“9¬-?_¼©˜©‰´¨Úˆ%~^—¸!/R
j—ƒ:É§|-š¢6¬¦í™·êÚ¨„²G)Ç¼¬Q•:`Õ¿µV]µØró·¥«øRˆî\ÊÊksmé†äß ZcSÔÇ‹0Ù»ÄvÁÃYtêcN>³¬-‡ê=ïcUPû}}p'ù•íoŠğê_Û+ÚÈ)À®„&Zıë)Š>.qmoT¥XJmmºÖ##âÂ–£µ¹ T0)ŞÃZdĞô¿f»;Ø=d$
ÉÎêKYÄ¶åô\ÀÿÃéo‡7‹KŒ§“_åZ[oÚH~çWÕF"!}MJÚlJÕÕ¶iDÓ§€,Çƒ·Î›D+şû¹ßÆäbVZR˜Ë¹|ç›3—ÓwïWËUçCH¼(ñ±C‰‡‘u…ïùèc‡ĞiÔv¦˜ø˜a¶í¸QBÂ Ä¾Ïğ¯$déğËÉÙt4aŒ²ïÜõ~ÖÑ^äÆ1ÎåçË+óÎ?Ÿß.C}Ç½”D'¹6,„Çª%HˆÇCJ
ì~:QàF1¢>¡Òs—{Ë´y e(}âÓçË0>8urÓûEò£”0ÆeÌ}°ÙaÌñqŒ¹Äá³Kü($[Ú8™N¿Mó³/_ş8;ÿk¨'¿‘B‡ÈZa—IÁçnİ€ÁÖ '8İ-¸2È™Ÿªv2ø¥qà&O%Úu*c%Õ wİQ‹˜Wlµûğ³jÕ"îòĞ»Lâ¥meÖ¼k°ş¡Œ´èÍßŸ")yXpU4œ.0ÿŠãØ]`;µ¸ÖÎ‚ƒFc‹±½Àw³\`.f\¸ =i·Êœ²h»0v\=,ïú E†yÂâ,Áå ä­Ü0’„÷ñM²p„Wœ¹ ‘3#€½%E½Ê‘›‹ÊŒô²!Z±\MN_P97¶S5 PªÀHE&ç=šX›„h<FG;º/„¥ÚÆZ_IÂÆ˜
2[á©¦A(Ã.¤’#€‹âhÉi+´_[+°DYsár!ú¥)Y¨~|¿ÂÇ~.^Ç…€&XÚ\Ô³Ğ!Rju¨=D½Y¯2y0Äz7äBFø1k´Çyk2ÌÖ<Ï•†ĞÖ'ëm)Ÿ^IÊ¸±ó»Fê©ÒLëm©]Ä`WŠçsÒÀyn²Xò!ºIxÚtg”²£Œ*¬ÕEÜYBz}4¯`Ò/ÅMÿ6¯báğt\Vš-ÙæµÚ L†ù-ûPnP
!Ùl
›ŒnnL)!”–‡I‚YJ¶(6R6MuR
Î³lùsnÿ4w¯;Í-ë*»¥N“U	‘D(î¾ıp>¨ªö(á!)Û\UÖÕ|¨ÆãKm—åfF$ã¤æ]—åºcJÑ|Éè©KÈÏÚ‚šöG¶iÒ:Ñ¬'Ğ¿çù;¢aØL×¿ËÓ×Ÿ4LéöÀ‘Ï+Æ¿a§"¹¶#X#ÉA4sv"Ü³Ï)õšWÀˆÄ¼şZ¡ÖË+”,]'¥xÉpÁ¾6/"9‚J„¸áG‰À>5ÜúIWÆVÍˆ•*±t›ù3†[™ØWÄqîUWw@­C+ì÷ÔWmhmüH¬í‘Ü”Æ[[¨ßÉáŞßÔİ=Cª[ø»{›ekñÏÛ6­4íçèñ;* …ó\	åˆ/1Š	ø’E)/GåöÁîşÇÀnèOb@{ÉY=Êï/;KıûKÏm÷ºÊüı`Q
øîñ  ·Gé½‚¼O*O~%0¤½uÌ™Ãğ*}êºÕ›±ŞPxÒl*IÖYV©„”Çbc­¼ ß£—¬œWR«uŠ'}óĞ!ª§ (ŒylËJ­#*µÕ‚R]Ñh naç1ìáğ7öÍ÷oY …{ì‚ïĞFƒm¾ß¯"êc[à3lw¸ãô„'ÊìÑ}Kø*QÇiqH.S‹'[—V]cº ]qÏIKİ–azÉ‘xndœªoªø<¨y))˜ëFÌçÛ<³ª OÒàVcjˆŠñéF¦µ¼hH!y;V*ù±æLFx¢ß€^q³ü€²t})m/¹„PÂ!d)éò)åAZj…$C|/iù¯	(lŒ-aºH•²<”à—‡³á…¶¢*qŠ¡èÌIlÒªĞ™–=Ó§Èc=Ñ!%^Í¯- ¬Z(
	ø‰µo9TôëriêmÙh äî,Šì-ş/Laã_wŞŸş’OOÂ@Åïıs 8ØŞ©HŒ©.jxiH³¶S:Únkw	á»»» Š¢°‡Íf÷7ï½Ììé°)sèv’‡hôb¼?_'7·—w8Á 0àJLIù†DX.áéÀ¼{`V'ç’–yh„.ìÑ˜]EãíNz¡#ÕœuZ@WéV×e=§¶ûU#-4IÅµ4Ÿâv¥Bàs3Åş¯;ú~éÒT\‘~kÈ„A6pT¸C=µ$^ÂjSÎ‹Yè­FÌBÿje”‹Y©w…hÁz¬Üî¶‚DfÚ‰µ4MÔ'ccÔk»™Ë´œe6a!Ú~°™|`HØÙš^{­<Ï} VŠôşo´XK¯3n)©eº5±1öe Ò´ëïÒ€eF¿ĞºÃ³•’MO1†ïû+F³¸à¿BtI6!ÀAOMİµK»nK$ÿ»Ó"¨AîeÛùx2ï;Í²E>_dY²@ç¡]Cæ$ô%[ğJrŸWÔ¢ã¨±&Ã59Æ­‘jÒ˜dYq[0'ôõ?[„’NMêš³óëbZŒ¹àô¢QMB5tqÍGÖme…U7Íi¯o	ğ‡¥²º'jÀ‡éJkjM¥wğB^AœpÇHO’÷H=ØÇ¾jzø_–T9/µÆ*/Îyôqq“ïßJ³¦D¨ˆXbWˆP#DúpUÌòËÅdv/æùt4ñ‘£©C¿jØÕ†¹dHğ½›*¿ÔÛÖ¶.=‚ãŞÉÿò÷‰Ò¿Ê¢ò¥qÃ<ÌÆ`°ƒÊäPTßM3ş\ép0Øk©p­¬U2KÆ’ƒ(gùæ×1Ö­JH¨é ¹h³Œ¯†İŞ¬±³ï„Ü¡^‹&ƒ|ü ¥ÁŠÂ0†ï>E…DXõt«Å­((–®—=±LPÓ[Ÿ~§»UÔ®^ö~~¾o2½~¦³†Ã]aBjd<GÀ%Ú°3t(óÔµ©Å»/z3iå
/½D+ã=+·( F“iĞlv^òdïÌâ‘*T*ÁUxÒiªåîñ[/eÒ•áêÌo€-_*52¼jëzÖf“8.æñ|†Q4RÊsÜçPY.Ò‡5î\{yÀˆö¨K;êŸ ä °c×Â+)¥bùÇeªãş[æ-[¾*¶™ ¹ïR]kÛ@|×¯ØÊIPÙ}è“’4„FÑÒÛ„PÃ·Ê•÷Tİ	¥ÿ½{²bB ­N»3³³y¾)×›<O6èô‘¥GP0ïŒê!ÅAü5Ø=GÉQ{ëR K{R-4¶Ex	¸ç”·~$y^¯Y8Æç“†4Ê›‹›¦áìúk½¬+œ_v¦Klé»'ºlÒ¨SÙ"ËàwüáÖ8ş§í D¿„¨=œVgÉŸäò3W¨êoå“şÑ£-‚¶l|‡©”#es¸®Wå—ÍÍê^®ËåÕêŠŸÃĞñ4:Öµd%ÿ§Â„]+±ï]ïÅø˜åÿEù¹#ñllû:n†ÍfÇàA;B]—wK–©¦É‹ÅòÂ’Æ½qÎ¨ØXr«ú¸õ#ÓWÙäü°5qé‘Ğ(~k\‡>ô¨vÅ´–8¤f§¤XÏÇø¤Æã±t@Ï^T›sohAk	áS’T*ğeNÕOúbÃÕÁpt¯}JkoìY@jiÛe§‚¹ï½ÈşÏè_Å•moÚ0ÇßçSœªII$^Z„ÚT‹:µ˜´½Š2r!VƒÆ¦šúİw6Om¦0¶Rr¾ûùwöÅófÁtæyÖ¥‰xÏøbhY\‚T%ÆKËóÂÛ|´­YâÃŠ•e±ÌÎïÒ”V§7á8¼&‡Á°È
‹¥à<b)™àÑ\,‹¸D‡ì“ã6Àî6ı¦oÓÃÀv]øaıp	°å=+€¼»àù(’e÷­WÅg…Ü`s'˜8¶Vdo£up¡Àl®Ø÷á‰©LN;ˆİ‡WkxAú¯ÃÏÁNı6?Áç	+y¼D'Š´O¹Ğ„«p\Îî&ß¢i0MFôHV[¢ZT¶‚än¾HYÚß®s3u2®¦&û¾õ6]q¦à8>Á8M¢ñ§±î¨£Êºä’´šŠùºh[­w˜–.Ú¿ø›
Qã©m{åŞE,%–*xXÅ¹tü¤
óÜ!Ùú´¤¬ÜNğ„Ùƒ!‘S:²‰l@g¬:4Õ”õêi=é´"@â\ğd­àô“[UÁ&z+¡&¶[Ù3¦7ºïcßÈ§"Mƒà&
n¯ê¡gÕLTÆÊM"ş.¾BöÚG¡;Õ.‰UI—Ì°½v-¼÷—t–îà½öo¥_~™€·«ıeÏUå¨°;ş1ìŞ/l|D¾¥wü:úqU9«À‘-²-»R”y.$¿¾µúúIHGfğ_Ç4d6“ı¿úÒĞ‡Çéºp’Q~âÄÚ«ı	ÅTmkÛ0ş®_q+Ëç­KÇ–t!´.3­q2ØCxñ¹6u$Í²»Ñÿ¾“’u5lìÃf0’{îôÜé¤ X…ËU°šâm)o …¾.ÒLScºn_”¦Tò#‚è*"'‹÷küÜ–5Š"5Åéu“uyÅÑfs]hVæÀï°¶¾b­6:­‘¾ƒ¸ßoÒö‡MfïÃwôáºPà™ÛR±'’Õ7hH§7e÷.è“M¢Ri†÷¬$â±»u‰˜è¦âMáÍ_‘ä‹èMø øgJJ®²²–é¹–#„}8’ğlu¼Ë0^$šêlZM¥Ó¤pã÷JÉ›¼¬Ğò½?Ñ\iÕUßå;eOiÓV–œR_ ‰ˆ_ÇöTyS·è%×dÍ•F¹-ÓËÁ f`Ëô/~W!:k:¨)»Kk‘µÍó«Š“J¿ƒRfíÁØrÛ£ÛõñáŞ¿§?Š9ìÁ2/Exu¾=È?ıågo“}øãáaü½ä¬+eĞ­¦l{«ì)È”Dê=wÂw1õêîMø¯E½a|âÃQAY¨#VÊ†}¶3ŒÉ0›oÑãZè-:ñİğìùn<ñÙ'¥*§•ÁîÜÚG/ºØ¯âü ÅTßkÛ0~÷_q”€¨§iºniRÂæR³±š$cÍ–cEr-¹M7ú¿ïä¤NİÃ^6ƒá»ówçï~H·KÏs–LĞ†Ãå
¨U0	½"§%d\0È©Ls</ü"ß~è•ì¾â%‹sªóÉ]–á×ÅÇ0
opu]ä…Ã3pX©¹’q¢6-™‹ş½ËíõüO\‘n~9€KrD¯yÈyJŠ'0(‘Œç:)Û&ë´BÑ”¥.±ŠêÇÑ6%3Á£á‘›êššx2†gçzŠÒoÂOA#ü¥4%)/%İ07-'»Ğƒá<x¿¼›A4›Ï¢—hfªÛV Ò}¿	J®l»-Ÿü‰V·¨¦ÖS¨;¬€	dvn»f¼ë÷[œ¾mÆ¿xëòq 8”…F%¹Am’=BÌæqtÙ}sMY1KÙZávù\,â(Æ›R­Yi‚ûŠ
íÒ²¤Oàbù>L¦àŸ"4èÌ¢áĞ¿¨­aã?oĞ¨AzcÑùĞÂK;Ûo—ß­õ¶eü¶yøíà¬$eä`q©¬JiI$Rp¹>¢T<=²V-«lçÖüç.ÛN:¡†ovF#Ù¼âK^ñıë&¿÷¨d­_xH;[§h–¥Ù~T»³f§®!U’á"Ö‡)øáâî/Šÿº‰Ú”x¥¹£.œäLuâÔşÅTÛnÚ@}÷WL#¤5RæZRjµjğĞ*Š¬-^ãf×ñš”´Ê¿wfÔô¡/­%ËggÆg.kÏ›³¹ç9sa
0/
©–ÀèL(¨e	Ï!–©€„«w–ÛB(#µºw<oüyŒ	ˆ¯åâa#s&Ü$ƒÛ8Æ·³ãÉø.¯²$sdî£È)6\èuÆsá"¿§Üê9°NÍ¯ùÁ%«Vá§x‰E¢™•Ì ½;Vé¨™õg›ôM©)L5Dä2’dS¼§ PBDNKa}xv®†(ùzü)(JÒj! ’¹âká†!ù„ajğa<ŞÏo§_ÃY0MG‘eF›û—¡Â}¿	OµZRßÉŸıÉÍ¶ÆºÚîÛzûN%Î` 1p×ƒwõú‰Ozğ/n[>§€²ĞØ(Y 6%¾Ã$MÃÉÍ„Ï-ò —-	§-t±ˆ1Ş#ò"xØğÔ¸<Ïù¸X¾ƒ!4šç½ŞE§Ñm·üQM¢Z-¿ë“Õ²¾„Ú„,×)Q×†Û×o	¶[{+Û»Ş=Y'VÃ?5e®F³„,ì(’I¥ÙïBÙZG‚¨e*•jÅJÍl##vL»<±òÃWv0#ìÒíª`¼ëQÊeëW¸Å+Ü·tU¦ó÷Œ^¬ÌÀ#[Ùâil4çx‘j#öÜ<Ú‘V×Ó±àË×yÿÛø¯ûiŠÿxn§
g‰HS}æÕş³±/È(PPğˆwröğs÷putqÒ5Ğ3Ö3ĞÊ2P
@À@;&&F
`  `h`b`¬À0
h`¡ÎE!ƒ«(µ°4³(5>?/9UA˜ô‹’32ËRAIHİš«¸¤(517¾(5=³¸$µ(¾¼(±  µHC½ #±H]¬%ªE]Óš+3MAC1%5-3/5EC9}:ûû¹»º¨kj*Tƒİ QˆSBZbNq*ĞØZ4‡‚l·Ò×/I-.8î£ÔŠÌk.{»Ñ42
†/  